%option lang= "C++"
%option track_lines
%decls %{
	#include <deque>
	#include <iostream>
	#include <unordered_map>
	#include <tuple>
	#include "parser.hpp"
	#include "lexer.hpp"
	#include "common.hpp"

	enum class type_code{
		error_type,
		char_type,
		bool_type,
		int_type,
		id_type,
		func_type,
		array_type
	};

	class AstNode;
	using namespace std;
	using AstNodeList = deque<AstNode*>;
	//Symbols in functions are only their names followed by their type
	using FunctionSymbols= std::unordered_map<std::string, type_code, CaseIHash, CaseIPredicate>;
	//SymbolTypes are the type of that symbol and optionally an array to an extra set of symbols
	using SymbolType = std::tuple<type_code,int,FunctionSymbols>;
	//SymbolList contains a name followed by a SymbolType
	using SymbolList = std::unordered_map<std::string, SymbolType, CaseIHash, CaseIPredicate>;
	bool semanticsError(std::string errMsg, AstNode *node);
	extern SymbolList SymbolTable;
%}

%{
	#include "ast.hpp"
	SymbolList SymbolTable= {};
	bool semanticsError(std::string errMsg, AstNode *node){
		std::cerr<<"Semantics ERROR@:"<<node->getLinenum()<<std::endl<<errMsg<<std::endl;
		return false;
	}
%}

%node AstNode %abstract %typedef = {
}

%node ProgramNode AstNode = {
	AstNode* variableDeclsNode;
	AstNode* functionNProceduresDeclNode;
	AstNode* mainNode;

}

%node BinaryNode AstNode %abstract = {
	AstNode* left;
	AstNode* right;
}


%node ForStatementNode 	BinaryNode
%node FuncCallNode 		BinaryNode
%node ArrayAccessNode 	BinaryNode
%node FunctionUseNode 	BinaryNode
%node AssignmentNode 	BinaryNode

%node OperationNode BinaryNode %abstract

%node AdditionNode 			OperationNode
%node SubtractionNode 		OperationNode
%node OrNode 				OperationNode
%node MultiplicationNode 	OperationNode
%node EqualsNode 			OperationNode
%node LessThanEtNode 		OperationNode
%node GrtrThanEtNode 		OperationNode
%node GrtrThanNode 			OperationNode
%node LessThanNode 			OperationNode
%node DivisionNode 			OperationNode
%node ExponentNode 			OperationNode
%node AndNode 				OperationNode
%node ModulusNode 			OperationNode

%node UnaryNode AstNode %abstract = {
	AstNode* n;
}


%node ListNode AstNode %abstract = {
	AstNodeList child_list;
}

%node VariableDeclListNode ListNode

%node IdListNode ListNode
%node NumListNode ListNode
%node FuncsListNode ListNode
%node StatementListNode ListNode
%node ArgListNode ListNode
%node ExprListNode ListNode


%node IntDeclNode AstNode
%node BooleanDeclNode AstNode
%node CharDeclNode AstNode

%node NumberNode AstNode = {
	int value;
}

%node CharacterNode AstNode = {
	char value;
}

%node BooleanNode AstNode = {
	bool value;
}

%node TypedefNode BinaryNode

%node IdNode AstNode = {
	string value;
}

%node TypedefArrayNode AstNode = {
	AstNode* idNode;
	AstNode* NumberListNode;
	AstNode* primitiveTypeNode;
}

%node ProcedureNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node FunctionNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* returnTypeNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node BlockNode UnaryNode
%node ElseStatementNode UnaryNode
%node ReturnNode UnaryNode

%node IfStatementNode AstNode = {
	AstNode* expressionNode;
	AstNode* statementListNode;
	AstNode* elseNode;
}

%operation %virtual string		toString(AstNode* node)
%operation %virtual string		getOperatorString(OperationNode* node)
%operation %virtual string		getDelimiter(ListNode* node)
%operation %virtual bool		fillFunctionSymbols(FuncsListNode* node)
%operation %virtual bool		fillVariableSymbols(VariableDeclListNode *node)
%operation %virtual bool		doSemantics(AstNode *node)

doSemantics(ProgramNode){
	if (node->functionNProceduresDeclNode)
		node->functionNProceduresDeclNode->fillFunctionSymbols();
	if (node->variableDeclsNode)
		node->variableDeclsNode->fillVariableSymbols();
	mainNode->doSemantics();
}

doSemantics(ForStatementNode){

}

doSemantics(FuncCallNode){

}

doSemantics(ArrayAccessNode){

}

doSemantics(FunctionUseNode){

}

doSemantics(AssignmentNode){

}

doSemantics(AdditionNode){

}

doSemantics(SubtractionNode){

}

doSemantics(OrNode){

}

doSemantics(MultiplicationNode){

}

doSemantics(EqualsNode){

}

doSemantics(LessThanEtNode){

}

doSemantics(GrtrThanEtNode){

}

doSemantics(GrtrThanNode){

}

doSemantics(LessThanNode){

}

doSemantics(DivisionNode){

}

doSemantics(ExponentNode){

}

doSemantics(AndNode){

}

doSemantics(ModulusNode){

}

doSemantics(TypedefNode){

}

doSemantics(BlockNode){

}

doSemantics(ElseStatementNode){

}

doSemantics(ReturnNode){

}

doSemantics(VariableDeclListNode){

}

doSemantics(IdListNode){

}

doSemantics(NumListNode){

}

doSemantics(FuncsListNode){

}

doSemantics(StatementListNode){

}

doSemantics(ArgListNode){

}

doSemantics(ExprListNode){

}

doSemantics(IntDeclNode){

}

doSemantics(BooleanDeclNode){

}

doSemantics(CharDeclNode){

}

doSemantics(NumberNode){

}

doSemantics(CharacterNode){

}

doSemantics(BooleanNode){

}

doSemantics(IdNode){

}

doSemantics(TypedefArrayNode){

}

doSemantics(ProcedureNode){

}

doSemantics(FunctionNode){

}

doSemantics(IfStatementNode){

}

fillVariableSymbols(VariableDeclListNode){

}

fillFunctionSymbols(FuncsListNode){
	if (child_list[0]){
		static_cast<FuncsListNode*>(child_list[0])->fillFunctionSymbols();
	}
	if (child_list[1]->isA(FunctionNode_kind)){

	} else if (child_list[1]->isA(ProcedureNode_kind)){

	} else {
		semanticsError("Expected function or procedure", child_list[1])
	}
	//SymbolTable
	/*IdNode *FuncName= static_cast<IdNode*>(child_list[1]);
	if (SymbolTable.find(FuncName->value) == SymbolTable.end()){
		semanticsError("Symbol already declared", node);
		return false;
	} else {
		SymbolTable[FuncName->value]= {type_code::func_type, 4,{}};
	}*/
	return true;
}

toString(NumberNode){
	return std::to_string(value);
}

toString(CharacterNode){
	return std::string(value, 1);
}

toString(BooleanNode){
	return value ? "verdadero" : "falso";
}

toString(IdNode){
	return value;
}

toString(ProgramNode){
	std::string result= "";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	if (functionNProceduresDeclNode)
		result+= functionNProceduresDeclNode->toString();
	result+= mainNode->toString();
	return result;
}

toString(ListNode){
	std::string result= "";
	for (auto& child : child_list){
		if (child){
			result+= child->toString() + node->getDelimiter();
		}
	}
	result.pop_back();
	return result;
}

toString(ArgListNode){
	std::string result= "";
	if (child_list[0])
		result+= child_list[0]->toString() + " ";
	result+= child_list[1]->toString() + ",";
	if (child_list[2])
		result+= child_list[2]->toString();
	return result;
}

toString(VariableDeclListNode){
	std::string result= "";
	for (int x = 0 ; x < child_list.size(); x++){
		if (x==2){
			result+= " ";
		}
		if (child_list[x])
			result+= child_list[x]->toString();
	}
	result+= node->getDelimiter();
	return result;
}

toString(IntDeclNode){
	return "entero";
}

toString(CharDeclNode){
	return "caracter";
}

toString(BooleanDeclNode){
	return "booleano";
}

toString(OperationNode){
	string result= "";
	if (left){
		result+= left->toString();
	}
	if (right){
		result+= node->getOperatorString() + right->toString();
	}
	return result+"\n";
}

toString(TypedefArrayNode){
	string result= "Tipo ";
	result+= idNode->toString() + " es arreglo [";
	result+= NumberListNode->toString() + "] de ";
	result+= primitiveTypeNode->toString();
	return result;
}

toString(BlockNode){
	string result= "inicio\n";
	if (n)
		result+= n->toString();
	return result + "\nfin\n";
}

toString(ElseStatementNode){
	return n->toString();
}

toString(ReturnNode){
	string result= "retorne ";
	result+= n->toString();
	return result;
}

toString(ProcedureNode){
	string result= "procedimiento ";
	result+= idNode->toString();
	if (optionalArgsNode)
		result+= "(" + optionalArgsNode->toString() + ")";
	result+= "\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(FunctionNode){
	string result= "funcion ";
	result+= idNode->toString(); 
	if (optionalArgsNode)
		result+= "(" + optionalArgsNode->toString() + "):";
	result+= returnTypeNode->toString() + "\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(IfStatementNode){
	string result= "si ";
	result+= expressionNode->toString() + "\n";
	if (statementListNode)
		result+= statementListNode->toString();
	if (elseNode)
		result+= elseNode->toString();
	return result + "\nfinsi\n";
}

toString(ForStatementNode){
	string result= "Para ";
	result+= left->toString() + " hasta ";
	result+= right->toString();
	result+= " haga ";
	return result;
}

toString(FuncCallNode){
	string result= "Llamar ";
	result+= left->toString();
	if (right)
		result+= right->toString();
	return result;
}

toString(ArrayAccessNode){
	string result= "";
	result+= left->toString() + "[";
	result+= right->toString() + "]";
	return result;
}

toString(FunctionUseNode){
	string result= "";
	result+= left->toString();
	result+= "(" + right->toString() + ")";
	return result;
}

toString(AssignmentNode){
	string result= "";
	result+= left->toString() + "<-";
	result+= right->toString();
	return result;
}

toString(TypedefNode){
	string result= "tipo ";
	result+= left->toString() + " es ";
	result+= right->toString();
	return result;
}

getOperatorString(AdditionNode){
	return "+";
}

getOperatorString(SubtractionNode){
	return "-";
}

getOperatorString(OrNode){
	return "|";
}

getOperatorString(MultiplicationNode){
	return "*";
}

getOperatorString(EqualsNode){
	return "=";
}

getOperatorString(LessThanEtNode){
	return "<=";
}

getOperatorString(GrtrThanEtNode){
	return ">=";
}

getOperatorString(GrtrThanNode){
	return ">";
}

getOperatorString(LessThanNode){
	return "<";
}

getOperatorString(DivisionNode){
	return "/";
}

getOperatorString(ExponentNode){
	return "^";
}

getOperatorString(AndNode){
	return "&";
}

getOperatorString(ModulusNode){
	return "%";
}

getDelimiter(ListNode){
	return ",";
}

getDelimiter(VariableDeclListNode){
	return "\n";
}

getDelimiter(FuncsListNode){
	return "\n";
}

getDelimiter(StatementListNode){
	return "\n";
}