%option lang= "C++"
%option track_lines
%decls %{
	#include <deque>
	#include <iostream>
	#include <unordered_map>
	#include <tuple>
	#include "parser.hpp"
	#include "lexer.hpp"
	#include "common.hpp"

	enum class type_code{
		error_type,
		char_type,
		bool_type,
		int_type,
		id_type,
		func_type,
		array_type
	};

	class AstNode;
	using namespace std;
	using AstNodeList = deque<AstNode*>;
	//Symbols in functions are only their names followed by their type
	using FunctionSymbols= std::unordered_map<std::string, type_code, CaseIHash, CaseIPredicate>;
	//SymbolTypes are the type of that symbol and optionally an array to an extra set of symbols
	using SymbolType = std::tuple<type_code,int,FunctionSymbols>;
	//SymbolList contains a name followed by a SymbolType
	using SymbolList = std::unordered_map<std::string, SymbolType, CaseIHash, CaseIPredicate>;
	bool semanticsError(std::string errMsg, AstNode *node);
	extern SymbolList SymbolTable;
	extern SymbolType& CurrentContext;
	extern type_code temp;

%}

%{
	#include "ast.hpp"
	SymbolList SymbolTable= {};
	FunctionSymbols* currentContext= nullptr;
	type_code temp= type_code::error_type;
	bool semanticsError(std::string errMsg, AstNode *node){
		std::cerr<<"Semantics ERROR@:"<<node->getLinenum()<<std::endl<<errMsg<<std::endl;
		return false;
	}
%}

%node AstNode %abstract %typedef = {
}

%node ProgramNode AstNode = {
	AstNode* variableDeclsNode;
	AstNode* functionNProceduresDeclNode;
	AstNode* mainNode;

}

%node BinaryNode AstNode %abstract = {
	AstNode* left;
	AstNode* right;
}


%node ForStatementNode 	BinaryNode
%node FuncCallNode 		BinaryNode
%node ArrayAccessNode 	BinaryNode
%node FunctionUseNode 	BinaryNode
%node AssignmentNode 	BinaryNode

%node OperationNode BinaryNode %abstract

%node AdditionNode 			OperationNode
%node SubtractionNode 		OperationNode
%node OrNode 				OperationNode
%node MultiplicationNode 	OperationNode
%node EqualsNode 			OperationNode
%node LessThanEtNode 		OperationNode
%node GrtrThanEtNode 		OperationNode
%node GrtrThanNode 			OperationNode
%node LessThanNode 			OperationNode
%node DivisionNode 			OperationNode
%node ExponentNode 			OperationNode
%node AndNode 				OperationNode
%node ModulusNode 			OperationNode

%node UnaryNode AstNode %abstract = {
	AstNode* n;
}


%node ListNode AstNode %abstract = {
	AstNodeList child_list;
}

%node VariableDeclListNode ListNode

%node IdListNode ListNode
%node NumListNode ListNode
%node FuncsListNode ListNode
%node StatementListNode ListNode
%node ArgListNode ListNode
%node ExprListNode ListNode


%node IntDeclNode AstNode
%node BooleanDeclNode AstNode
%node CharDeclNode AstNode

%node NumberNode AstNode = {
	int value;
}

%node CharacterNode AstNode = {
	char value;
}

%node BooleanNode AstNode = {
	bool value;
}

%node TypedefNode BinaryNode

%node IdNode AstNode = {
	string value;
}

%node TypedefArrayNode AstNode = {
	AstNode* idNode;
	AstNode* NumberListNode;
	AstNode* primitiveTypeNode;
}

%node ProcedureNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node FunctionNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* returnTypeNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node BlockNode UnaryNode
%node ElseStatementNode UnaryNode
%node ReturnNode UnaryNode

%node IfStatementNode AstNode = {
	AstNode* expressionNode;
	AstNode* statementListNode;
	AstNode* elseNode;
}

%operation %virtual string		toString(AstNode* node)
%operation %virtual string		getOperatorString(OperationNode* node)
%operation %virtual string		getDelimiter(ListNode* node)
%operation %virtual bool		doSemantics(AstNode *node)

doSemantics(ProgramNode){
	if (node->functionNProceduresDeclNode)
		node->functionNProceduresDeclNode->doSemantics();
	//if (node->variableDeclsNode)
	//	node->variableDeclsNode->doSemantics();
	//mainNode->doSemantics();
	return true;
}

doSemantics(ForStatementNode){
	return true;
}

doSemantics(FuncCallNode){
	return true;
}

doSemantics(ArrayAccessNode){
	return true;
}

doSemantics(FunctionUseNode){
	return true;
}

doSemantics(AssignmentNode){
	return true;
}

doSemantics(AdditionNode){
	return true;
}

doSemantics(SubtractionNode){
	return true;
}

doSemantics(OrNode){
	return true;
}

doSemantics(MultiplicationNode){
	return true;
}

doSemantics(EqualsNode){
	return true;
}

doSemantics(LessThanEtNode){
	return true;
}

doSemantics(GrtrThanEtNode){
	return true;
}

doSemantics(GrtrThanNode){
	return true;
}

doSemantics(LessThanNode){
	return true;
}

doSemantics(DivisionNode){
	return true;
}

doSemantics(ExponentNode){
	return true;
}

doSemantics(AndNode){
	return true;
}

doSemantics(ModulusNode){
	return true;
}

doSemantics(TypedefNode){
	return true;
}

doSemantics(BlockNode){
	return true;
}

doSemantics(ElseStatementNode){
	return true;
}

doSemantics(ReturnNode){
	return true;
}

doSemantics(VariableDeclListNode){
	if (child_list[0])
		child_list[0]->doSemantics();
	if (child_list[1]->isA(TypedefNode_kind) || child_list[1]->isA(TypedefArrayNode_kind)){
		child_list[1]->doSemantics();
	} else if (child_list[1]->isA(IntDeclNode_kind)){
		temp= type_code::int_type;
	}
	else if (child_list[1]->isA(CharDeclNode_kind)){
		temp= type_code::char_type;
	}
	else if (child_list[1]->isA(BooleanDeclNode_kind)){
		temp= type_code::bool_type;
	}
	if (child_list[2]->isA(NumberNode_kind)){
		temp= type_code::array_type;
		child_list[3]->doSemantics();
	} else {
		child_list[2]->doSemantics();

	}
	return true;

}

doSemantics(IdListNode){
	if (child_list[1])
		child_list[1]->doSemantics();
	IdNode* name= static_cast<IdNode*>(child_list[0]);
	if (!currentContext){
		if (SymbolTable.find(name->value) != SymbolTable.end()){
			semanticsError("Symbol already defined within function", node);
			return false;
		} else {
			SymbolTable[name->value]= {temp, 4, {}};
		}
	} else {
		if (currentContext->find(name->value) != currentContext->end()){
			semanticsError("Symbol already defined within function", node);
			return false;
		} else {
			(*currentContext)[name->value]= temp;
		}
	}
	return true;
}

doSemantics(NumListNode){
	return true;
}

doSemantics(FuncsListNode){
	if (child_list[0]){
		child_list[0]->doSemantics();
	}
	child_list[1]->doSemantics();
	return true;
}

doSemantics(StatementListNode){
	return true;
}

doSemantics(ArgListNode){
	if (!currentContext){
		semanticsError("Internal error, didnt set current context before putting arguments in VTable", node);
		return false;
	}
	if (child_list[2]){
		child_list[2]->doSemantics();
	}
	IdNode* name= static_cast<IdNode*>(child_list[1]);
	if (currentContext->find(name->value) != currentContext->end()){
		semanticsError("Symbol already defined within function", node);
		return false;
	}
	if (child_list[0]->isA(IntDeclNode_kind)){
		(*currentContext)[name->value]= type_code::int_type;
	} else if (child_list[0]->isA(CharDeclNode_kind)){
		(*currentContext)[name->value] = type_code::char_type;
	} else if (child_list[0]->isA(BooleanDeclNode_kind)){
		(*currentContext)[name->value] = type_code::bool_type;
	}
	return true;
}

doSemantics(ExprListNode){
	return true;
}

doSemantics(IntDeclNode){
	return true;
}

doSemantics(BooleanDeclNode){
	return true;
}

doSemantics(CharDeclNode){
	return true;

}

doSemantics(NumberNode){
	return true;

}

doSemantics(CharacterNode){
	return true;

}

doSemantics(BooleanNode){
	return true;

}

doSemantics(IdNode){
	return true;

}

doSemantics(TypedefArrayNode){
	return true;

}

doSemantics(IfStatementNode){
	return true;
}

doSemantics(ProcedureNode){
	//SymbolTable
	IdNode *ProcName= static_cast<IdNode*>(idNode);
	if (SymbolTable.find(ProcName->value) != SymbolTable.end()){
		semanticsError("Symbol already declared", node);
		return false;
	} else {
		SymbolTable[ProcName->value]= {type_code::func_type, 4,{}};
		currentContext= &std::get<2>(SymbolTable[ProcName->value]);
	}
	if (node->optionalArgsNode){
		node->optionalArgsNode->doSemantics();
	}
	if (node->variableDeclsNode){
		node->variableDeclsNode->doSemantics();
	}
	node->blockNode->doSemantics();
	currentContext= nullptr;
	temp= type_code::error_type;
	return true;
}

doSemantics(FunctionNode){
	IdNode *FuncName= static_cast<IdNode*>(idNode);
	if (SymbolTable.find(FuncName->value) != SymbolTable.end()){
		semanticsError("Symbol already declared", node);
		return false;
	} else {
		SymbolTable[FuncName->value]= {type_code::func_type, 4,{}};
		currentContext= &std::get<2>(SymbolTable[FuncName->value]);
	}
	if (node->optionalArgsNode){
		node->optionalArgsNode->doSemantics();
	}
	if (node->variableDeclsNode){
		node->variableDeclsNode->doSemantics();
	}
	currentContext= nullptr;
	temp= type_code::error_type;

	return true;
}


toString(NumberNode){
	return std::to_string(value);
}

toString(CharacterNode){
	return std::string(value, 1);
}

toString(BooleanNode){
	return value ? "verdadero" : "falso";
}

toString(IdNode){
	return value;
}

toString(ProgramNode){
	std::string result= "";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	if (functionNProceduresDeclNode)
		result+= functionNProceduresDeclNode->toString();
	result+= mainNode->toString();
	return result;
}

toString(ListNode){
	std::string result= "";
	for (auto& child : child_list){
		if (child){
			result+= child->toString() + node->getDelimiter();
		}
	}
	result.pop_back();
	return result;
}

toString(ArgListNode){
	std::string result= "";
	if (child_list[0])
		result+= child_list[0]->toString() + " ";
	result+= child_list[1]->toString() + ",";
	if (child_list[2])
		result+= child_list[2]->toString();
	return result;
}

toString(VariableDeclListNode){
	std::string result= "";
	for (int x = 0 ; x < child_list.size(); x++){
		if (x==2){
			result+= " ";
		}
		if (child_list[x])
			result+= child_list[x]->toString();
	}
	result+= node->getDelimiter();
	return result;
}

toString(IntDeclNode){
	return "entero";
}

toString(CharDeclNode){
	return "caracter";
}

toString(BooleanDeclNode){
	return "booleano";
}

toString(OperationNode){
	string result= "";
	if (left){
		result+= left->toString();
	}
	if (right){
		result+= node->getOperatorString() + right->toString();
	}
	return result+"\n";
}

toString(TypedefArrayNode){
	string result= "Tipo ";
	result+= idNode->toString() + " es arreglo [";
	result+= NumberListNode->toString() + "] de ";
	result+= primitiveTypeNode->toString();
	return result;
}

toString(BlockNode){
	string result= "inicio\n";
	if (n)
		result+= n->toString();
	return result + "\nfin\n";
}

toString(ElseStatementNode){
	return n->toString();
}

toString(ReturnNode){
	string result= "retorne ";
	result+= n->toString();
	return result;
}

toString(ProcedureNode){
	string result= "procedimiento ";
	result+= idNode->toString();
	if (optionalArgsNode)
		result+= "(" + optionalArgsNode->toString() + ")";
	result+= "\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(FunctionNode){
	string result= "funcion ";
	result+= idNode->toString(); 
	if (optionalArgsNode)
		result+= "(" + optionalArgsNode->toString() + "):";
	result+= returnTypeNode->toString() + "\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(IfStatementNode){
	string result= "si ";
	result+= expressionNode->toString() + "\n";
	if (statementListNode)
		result+= statementListNode->toString();
	if (elseNode)
		result+= elseNode->toString();
	return result + "\nfinsi\n";
}

toString(ForStatementNode){
	string result= "Para ";
	result+= left->toString() + " hasta ";
	result+= right->toString();
	result+= " haga ";
	return result;
}

toString(FuncCallNode){
	string result= "Llamar ";
	result+= left->toString();
	if (right)
		result+= right->toString();
	return result;
}

toString(ArrayAccessNode){
	string result= "";
	result+= left->toString() + "[";
	result+= right->toString() + "]";
	return result;
}

toString(FunctionUseNode){
	string result= "";
	result+= left->toString();
	result+= "(" + right->toString() + ")";
	return result;
}

toString(AssignmentNode){
	string result= "";
	result+= left->toString() + "<-";
	result+= right->toString();
	return result;
}

toString(TypedefNode){
	string result= "tipo ";
	result+= left->toString() + " es ";
	result+= right->toString();
	return result;
}

getOperatorString(AdditionNode){
	return "+";
}

getOperatorString(SubtractionNode){
	return "-";
}

getOperatorString(OrNode){
	return "|";
}

getOperatorString(MultiplicationNode){
	return "*";
}

getOperatorString(EqualsNode){
	return "=";
}

getOperatorString(LessThanEtNode){
	return "<=";
}

getOperatorString(GrtrThanEtNode){
	return ">=";
}

getOperatorString(GrtrThanNode){
	return ">";
}

getOperatorString(LessThanNode){
	return "<";
}

getOperatorString(DivisionNode){
	return "/";
}

getOperatorString(ExponentNode){
	return "^";
}

getOperatorString(AndNode){
	return "&";
}

getOperatorString(ModulusNode){
	return "%";
}

getDelimiter(ListNode){
	return ",";
}

getDelimiter(VariableDeclListNode){
	return "\n";
}

getDelimiter(FuncsListNode){
	return "\n";
}

getDelimiter(StatementListNode){
	return "\n";
}