%option lang= "C++"

%decls %{
	#include <deque>
	#include "parser.hpp"
	#include <iostream>
	#include "common.hpp"
	
	class AstNode;
	using namespace std;
	using AstNodeList = deque<AstNode*>;
%}

%{
	#include "ast.hpp"
%}

%enum type_code= {
	int_type,
	char_type,
	bool_type,
	error_type,
	id_type,
	variable_list_type,
	int_decl_type,
	bool_decl_type,
	char_decl_type,
	typedef_decl_type,
	statement_type
}

%node AstNode %abstract %typedef = {
	%nocreate type_code type = {error_type};
}

%node BinaryNode AstNode %abstract = {
	AstNode* left;
	AstNode* right;
}


%node ForStatementNode 	BinaryNode
%node FuncCallNode 		BinaryNode
%node ArrayAccessNode 	BinaryNode
%node FunctionUseNode 	BinaryNode
%node AssignmentNode 	BinaryNode

%node OperationNode BinaryNode %abstract

%node AdditionNode 			OperationNode
%node SubtractionNode 		OperationNode
%node OrNode 				OperationNode
%node MultiplicationNode 	OperationNode
%node EqualsNode 			OperationNode
%node LessThanEtNode 		OperationNode
%node GrtrThanEtNode 		OperationNode
%node GrtrThanNode 			OperationNode
%node LessThanNode 			OperationNode
%node DivisionNode 			OperationNode
%node ExponentNode 			OperationNode
%node AndNode 				OperationNode
%node ModulusNode 			OperationNode

%node UnaryNode AstNode %abstract = {
	AstNode* n;
}


%node ListNode AstNode %abstract = {
	AstNodeList child_list;
}

%node VariableDeclListNode ListNode
%node IdListNode ListNode
%node NumListNode ListNode
%node FuncsListNode ListNode
%node StatementListNode ListNode
%node ArgListNode ListNode
%node ExprListNode ListNode


%node IntDeclNode AstNode
%node BooleanDeclNode AstNode
%node CharDeclNode AstNode

%node NumberNode AstNode = {
	int value;
}

%node CharacterNode AstNode = {
	char value;
}

%node BooleanNode AstNode = {
	bool value;
}

%node TypedefNode BinaryNode

%node IdNode AstNode = {
	string value;
}

%node TypedefArrayNode AstNode = {
	AstNode* idNode;
	AstNode* NumberListNode;
	AstNode* primitiveTypeNode;
}

%node ProcedureNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node FunctionNode AstNode = {
	AstNode* idNode;
	AstNode* optionalArgsNode;
	AstNode* returnTypeNode;
	AstNode* variableDeclsNode;
	AstNode* blockNode;
}

%node BlockNode UnaryNode
%node ElseStatementNode UnaryNode
%node ReturnNode UnaryNode

%node IfStatementNode AstNode = {
	AstNode* expressionNode;
	AstNode* statementListNode;
	AstNode* elseNode;
}




%operation void infer_type(AstNode* node)
%operation %virtual string toString(AstNode* node)
%operation %virtual string getOperatorString(OperationNode* node)

infer_type(NumberNode){
	node->type = int_type;
}

infer_type(CharacterNode){
	node->type = char_type;
}

infer_type(BooleanNode){
	node->type = bool_type;
}

infer_type(IdNode){
	node->type = id_type;
}

infer_type(ListNode){
}

infer_type(IntDeclNode){
	node->type = int_decl_type;
}

infer_type(BooleanDeclNode){
	node->type = bool_decl_type;
}

infer_type(CharDeclNode){
	node->type = char_decl_type;
}

infer_type(TypedefNode){

}

infer_type(ForStatementNode){
	node->type= statement_type;
}

infer_type(FuncCallNode){
	node->type= statement_type;
}

infer_type(ArrayAccessNode){
	node->type= statement_type;
}

infer_type(FunctionUseNode){
	node->type= statement_type;
}

infer_type(AssignmentNode){
	node->type= statement_type;
}

infer_type(BlockNode){
	node->type= statement_type;
}

infer_type(ElseStatementNode){
	node->type= statement_type;
}

infer_type(ReturnNode){
	node->type= statement_type;
}

infer_type(ProcedureNode){
	node->type= statement_type;
}

infer_type(FunctionNode){
	node->type= statement_type;
}

infer_type(IfStatementNode){
	node->type= statement_type;
}

infer_type(TypedefArrayNode){
	node->type= statement_type;
}

infer_type(OperationNode){
	infer_type(node->left);
	infer_type(node->right);

	if(node->left->type == error_type || node->right->type == error_type){
		node->type = error_type;
	}
    else if(node->right->type != int_type){
		cerr << node->getFilename() << ":" << node->getLinenum() <<
        		": second argument to `^' is not an integer" << endl;
		node->type = error_type;
    }
	else{
    	node->type = node->left->type;
	}
}

toString(NumberNode){
	return std::to_string(value);
}

toString(CharacterNode){
	return std::string(value, 1);
}

toString(BooleanNode){
	return value ? "verdadero" : "falso";
}

toString(IdNode){
	return value;
}

toString(ListNode){
	std::string result= "";
	for (auto& child : child_list){
		if (child){
			result+= child->toString() + "\n";
		}
	}
	//result.pop_back();
	/*if (child_list.size() == 3){
		for (int x= 0 ; x<child_list.size(); x+=3){
			if (child_list[x])
				result+= child_list[x]->toString()+"\n";
			result+= child_list[x+1]->toString() + " ";
			result+= child_list[x+2]->toString();
		};
	}*/
	return result;
}

toString(IntDeclNode){
	return "entero";
}

toString(CharDeclNode){
	return "caracter";
}

toString(BooleanDeclNode){
	return "booleano";
}

toString(OperationNode){
	string result= "";
	if (left){
		result+= left->toString();
	}
	if (right){
		result+= node->getOperatorString() + right->toString();
	}
	return result+"\n";
}

toString(TypedefArrayNode){
	string result= "Tipo ";
	result+= idNode->toString() + " es arreglo [";
	result+= NumberListNode->toString() + "] de ";
	result+= primitiveTypeNode->toString();
	return result;
}

toString(BlockNode){
	string result= "inicio\n";
	if (n)
		result+= n->toString();
	return result + "\nfin\n";
}

toString(ElseStatementNode){
	return n->toString();
}

toString(ReturnNode){
	string result= "retorne ";
	result+= n->toString();
	return result;
}

toString(ProcedureNode){
	string result= "procedimiento ";
	result+= idNode->toString();
	if (optionalArgsNode) 
		result+= "(" + optionalArgsNode->toString() + ")\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(FunctionNode){
	string result= "funcion ";
	result+= idNode->toString(); 
	if (optionalArgsNode)
		result+= "(" + optionalArgsNode->toString() + "):";
	result+= returnTypeNode->toString() + "\n";
	if (variableDeclsNode)
		result+= variableDeclsNode->toString();
	result+= blockNode->toString();
	return result;
}

toString(IfStatementNode){
	string result= "si ";
	result+= expressionNode->toString() + "\n";
	if (statementListNode)
		result+= statementListNode->toString();
	if (elseNode)
		result+= elseNode->toString();
	return result + "finsi";
}

toString(ForStatementNode){
	string result= "Para ";
	result+= left->toString() + " hasta ";
	result+= right->toString();
	result+= "haga";
	return result;
}

toString(FuncCallNode){
	string result= "Llamar ";
	result+= left->toString();
	if (right)
		result+= right->toString();
	return result;
}

toString(ArrayAccessNode){
	string result= "";
	result+= left->toString() + "[";
	result+= right->toString() + "]";
	return result;
}

toString(FunctionUseNode){
	string result= "";
	result+= left->toString();
	result+= "(" + right->toString() + ")";
	return result;
}

toString(AssignmentNode){
	string result= "";
	result+= left->toString() + "<-";
	result+= right->toString();
	return result;
}

toString(TypedefNode){
	string result= "tipo ";
	result+= left->toString() + " es ";
	result+= right->toString();
	return result;
}

getOperatorString(AdditionNode){
	return "+";
}

getOperatorString(SubtractionNode){
	return "-";
}

getOperatorString(OrNode){
	return "|";
}

getOperatorString(MultiplicationNode){
	return "*";
}

getOperatorString(EqualsNode){
	return "=";
}

getOperatorString(LessThanEtNode){
	return "<=";
}

getOperatorString(GrtrThanEtNode){
	return ">=";
}

getOperatorString(GrtrThanNode){
	return ">";
}

getOperatorString(LessThanNode){
	return "<";
}

getOperatorString(DivisionNode){
	return "/";
}

getOperatorString(ExponentNode){
	return "^";
}

getOperatorString(AndNode){
	return "&";
}

getOperatorString(ModulusNode){
	return "%";
}